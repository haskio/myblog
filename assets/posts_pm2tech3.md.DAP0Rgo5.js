import{_ as t,c as p,a,b as i,t as l,a4 as r,o}from"./chunks/framework.CR4Iiru0.js";const s="/assets/359915915240450.Bsn3AToy.png",n="/assets/173360016258876.vznGt_96.png",g=JSON.parse('{"title":"3.常见的系统级框架","description":"框架是什么，常见的有那些框架","frontmatter":{"date":"2024-04-09T00:00:00.000Z","title":"3.常见的系统级框架","category":"产品经理必须要懂的技术","description":"框架是什么，常见的有那些框架","tags":["框架","web系统框架"]},"headers":[],"relativePath":"posts/pm2tech3.md","filePath":"posts/pm2tech3.md"}'),h={name:"posts/pm2tech3.md"},c={id:"frontmatter-title",tabindex:"-1"},d=a("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),u=r('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>提到架构就不得不提框架。</p><p>架构我们上一节讲到，是指系统的结构，那么对于某种结构，我们需要按照其结构完成对应的功能和开发。</p><p>那么有没有能帮助填充好，或者已完成部分工作的呢？</p><p>有的，那就是框架。</p><p>就像我们写ppt或者word，比较好的结构是有封面，有目录页，有页眉/页脚，有结尾等，如果我们自己做，就需要从头开始，每个地方都要做一些。</p><p>但是可以用一些别人做好的，或者自己上次使用过的文档，那么直接改成自己想要的内容就可以了，工作量立省一大半。</p><p>所以你也可以理解框架是一种模板。</p><h2 id="常见的框架" tabindex="-1">常见的框架 <a class="header-anchor" href="#常见的框架" aria-label="Permalink to &quot;常见的框架&quot;">​</a></h2><h3 id="web系统框架" tabindex="-1">web系统框架 <a class="header-anchor" href="#web系统框架" aria-label="Permalink to &quot;web系统框架&quot;">​</a></h3><p>在目前的web系统体系中，比较流行的是单体项目架构、前后端分离项目架构、微服务项目架构。</p><h4 id="前后端不分离" tabindex="-1">前后端不分离 <a class="header-anchor" href="#前后端不分离" aria-label="Permalink to &quot;前后端不分离&quot;">​</a></h4><p>前后端不分离，都在一个程序包中，也就是一套系统里可以实现从数据库读取到页面呈现的所有功能。</p><p>典型的就是php的thinkphp和Larave，用户看到的页面其实都是php文件，php文件通过调用相关服务呈现出了html文件的燕子。</p><p>这种架构是之前颇为流行，现在也有一些场景还在使用。</p><h4 id="前后端分离项目架构" tabindex="-1">前后端分离项目架构 <a class="header-anchor" href="#前后端分离项目架构" aria-label="Permalink to &quot;前后端分离项目架构&quot;">​</a></h4><p>项目分为两个系统，两个项目独自开发，独立部署，通过接口的进行数据通信。</p><p>前端系统负责界面现实，显示内容。 后端系统是指程序或者服务，负责逻辑、数据计算。</p><p>例如查看用户余额的时候，前端系统向后端系统请求余额数据，后端系统返回对应的数据，例如： <img src="'+s+'" alt=""></p><p>而前端系统根据获得的数据进行显示。 <img src="'+n+'" alt=""></p><p>前端常见的web框架有</p><ul><li>vue</li><li>react</li><li>angular</li></ul><p>前端常见的APP/HTML5框架</p><ul><li>uniapp： 跨平台，一套代码，多端发布</li><li>flutter： 跨平台，一套代码，多端发布</li><li>react-native： 跨平台，一套代码，多端发布</li><li>weex： 跨平台，一套代码，多端发布</li><li>taro： 跨平台，一套代码，多端发布</li><li>终端原生： 使用每种终端的sdk 研发。</li></ul><p>前端的发展比较快，随时都会有新的框架出现。</p><p>后端框架：</p><ul><li>java：sprintboot</li><li>c#/net：.net webapi</li><li>go： gin</li></ul><h4 id="微服务架构" tabindex="-1">微服务架构 <a class="header-anchor" href="#微服务架构" aria-label="Permalink to &quot;微服务架构&quot;">​</a></h4><p>微服务是指将后端服务拆分成了1+多模式，或者多+多模式。 以1+多模式，相当于使用服务的时候，都去找一个领头的人，然后他会分配一个具体干活的人来负责。 实现的过程简单来说就是： 第一，所有干活的人都要先去领头哪里报道，这一部分称为服务发现。 这个负责领导的人，我们称之为服务网关。</p><p>第二，当有请求时，由领头的根据规则和类型分配给具体某个干活的服务。</p><p>第三，领头的会时不时询问干活的人，还能不能继续接受新任务，以及还在不在，不如服务的离线。</p><p>微服务架构主要讨论实现微服务的体系，不讨论所对应的后端框架。</p><ul><li>java： Springcloud、Dubbo</li><li>.net： Consul 、Service Fabric（托管）</li><li>go： go-zero、gRPC</li><li>rpc框架： ZeroC-Ice、Thrift、Tars</li></ul><h3 id="客户端框架" tabindex="-1">客户端框架 <a class="header-anchor" href="#客户端框架" aria-label="Permalink to &quot;客户端框架&quot;">​</a></h3><p>是指做独立客户端应用的框架，例如常用的QQ就是一个客户端，客户端跟操作系统关系比较大，当然也有一些号称跨平台的方案，但是并不是太好。 毕竟选择用客户端就说明有性能、本地存储之类的需求，如果最后开发完之后实现不了这些还不如用web端解决方案。</p><h2 id="选择框架" tabindex="-1">选择框架 <a class="header-anchor" href="#选择框架" aria-label="Permalink to &quot;选择框架&quot;">​</a></h2><p>框架的选择是由技术团队来选择，产品人员一般了解即可，但是在技术选型的过程中，产品人员需要提供功能范围和需求供技术人员参考。</p><p>因为框架的好坏难以一言盖之，产品使用什么框架也需要根据自身的情况来考虑， 例如团队实力、交付周期、客户要求、功能特点。</p><p>具体来说就是如果是简单的功能，并且交付周期比较短，就选择较为容易上手的框架。 如果是复杂的功能，或者交付时间比较长，那么可以考虑更成熟或者性能更好的框架，甚至自己打造一个框架。</p><p>例如要做一款客户端，需要涉及到很多硬件设备的调用，那么需要提前告知开发人员，否则选择一些混合模式的框架可能就无法调用或者调用很困难。</p><h2 id="这是框架的问题-改不了" tabindex="-1">这是框架的问题，改不了 <a class="header-anchor" href="#这是框架的问题-改不了" aria-label="Permalink to &quot;这是框架的问题，改不了&quot;">​</a></h2><p>不得不说，这可能是产品人员在提需求的时候，经常被拒绝的理由之一。那么到底是是不是框架的问题呢？ 实际上情况会分几种： 1、框架没问题，但是使用的方式有问题 框架本身没有问题，但是使用方式错了，导致框架报错了，所以技术人员说是框架的问题。</p><p>2、对框架不熟，导致某些功能不了解不会用。 框架一般包含很多的功能，如果只用一些表面的功能而不深入研究，对于某些功能点是不太了解，好比大多数人都只用excel做做表单，但是对于公式、数据透视表之类的基本都不太了解，然后就反馈说excel做不了。</p><p>3、框架确实做不了，绕过方式又太麻烦。 框架虽然做不了，不过框架作者提供了扩展方案，然而技术团队不想学习或者觉得扩展的技术门槛太高、太耗人工之类的原因，不愿意做。</p><p>4、确实做不了。 真的做不了，如果想实现对应的功能，唯有换框架。</p><p>对于以上几种情况，实际上前三种的比较多，尤其是第二种， 一般是技术团队的任务比较重，又不给技术人员了解学习的时间，所以才会产生一开始的问题，碰到问题就说是框架的问题。</p><p>具体是那种问题，其实应该由技术总监或者技术经理来判断，产品人员需要提供的就是该需求的重要程度以及优先级。如果是可有可无的需求或者优先级没那么高，那么就需要放一放了。</p><p>而如果是重要的需求，即使是难度很大，也是需要技术团队去攻克。</p><p>总结 以上是简单一些跟架构相关的系统级别框架，还有其他更底层或者更技术的框架作为整体系统的补充，就不在此讲解。</p>',49);function b(e,_,m,f,q,P){return o(),p("div",null,[a("h1",c,[i(l(e.$frontmatter.title)+" ",1),d]),u])}const k=t(h,[["render",b]]);export{g as __pageData,k as default};
